import * as esbuild from 'esbuild';
import * as path from 'path';
import * as fs from 'fs';

export interface BackendBundleOptions {
  /** The input TypeScript file to bundle */
  inputFile: string;
  /** Base directory of the project (for resolving relative imports) */
  baseDir?: string;
  /** Output file path for the bundled JavaScript */
  outfile: string;
  /** Whether to minify the output */
  minify?: boolean;
  /** Whether to generate source maps */
  sourcemap?: boolean;
  /** Target Node.js version */
  target?: string;
}

export interface BackendBundleResult {
  /** The path to the output file */
  outfile: string;
  /** The source map file path (if sourcemap was enabled) */
  mapfile?: string;
  /** Any build warnings */
  warnings: esbuild.Message[];
  /** Build metadata */
  metafile?: esbuild.Metafile;
}

/**
 * Bundles a generated backend server program into a single runnable JavaScript file using esbuild
 */
export async function bundleBackendProgram(options: BackendBundleOptions): Promise<BackendBundleResult> {
  const {
    inputFile,
    baseDir = process.cwd(),
    outfile,
    minify = false,
    sourcemap = false,
    target = 'node18'
  } = options;

  try {
    // Parse the input file to extract route import paths
    const fileContent = fs.readFileSync(inputFile, 'utf-8');
    const routeImports: string[] = [];
    const importRegex = /import\s+{[^}]+}\s+from\s+["']([^"']+)["']/g;
    let match;
    while ((match = importRegex.exec(fileContent)) !== null) {
      const importPath = match[1];
      // Add route imports to external list (exclude framework imports)
      if (importPath.startsWith('src/api/') && importPath.endsWith('/route.ts')) {
        routeImports.push(importPath);
      }
    }

  // Configure esbuild for Node.js bundling
  const esbuildOptions: esbuild.BuildOptions = {
    entryPoints: [inputFile],
    bundle: true,
    platform: 'node',
    target: target,
    format: 'cjs', // was 'esm', changed to 'cjs' for better compatibility
    outfile: outfile,
    minify: minify,
    sourcemap: sourcemap,
    // Externalize Node.js built-ins, common packages, and route files
    external: [
      'fs',
      'path',
      'http',
      'https',
      'url',
      'querystring',
      'crypto',
      'util',
      'stream',
      'zlib',
      'events',
      'os',
      'child_process',
      'cluster',
      'worker_threads',
      'buffer',
      'assert',
      'constants',
      'timers',
      'dns',
      'net',
      'tls',
      'v8',
      'vm',
      // Externalize the framework itself since it will be a dependency
      //'@peaque/framework',
      // Externalize all route imports
      //...routeImports
    ],
    // Resolve imports relative to the base directory
    absWorkingDir: baseDir,
    // Handle TypeScript and JavaScript
    loader: {
      '.ts': 'ts',
      '.js': 'js',
      '.mjs': 'js',
      '.cjs': 'js'
    },
    // Resolve extensions
    resolveExtensions: ['.ts', '.js', '.mjs', '.cjs', '.json'],
    // Define environment variables
    define: {
      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'production')
    },
    // Banner for the output file
    banner: {
      js: `#!/usr/bin/env node\n// Generated by Peaque Framework Backend Bundler\n`
    },
    // Additional options for better compatibility
    mainFields: ['module', 'main'],
    conditions: ['node'],
    // Keep names for better debugging
    keepNames: !minify,
    // Tree shaking
    treeShaking: true,
    // Generate metafile for analysis
    metafile: true
  };    // Run esbuild
    const result = await esbuild.build(esbuildOptions);

    // Check for build errors
    if (result.errors.length > 0) {
      const errorMessages = result.errors.map(error =>
        `${error.location?.file}:${error.location?.line}:${error.location?.column} - ${error.text}`
      );
      throw new Error(`Build failed:\n${errorMessages.join('\n')}`);
    }

    // Log warnings if any
    if (result.warnings.length > 0) {
      console.warn('Build warnings:');
      result.warnings.forEach(warning => {
        console.warn(`  ${warning.location?.file}:${warning.location?.line}:${warning.location?.column} - ${warning.text}`);
      });
    }

    // Determine the output files
    const mapfile = sourcemap ? outfile + '.map' : undefined;

    console.log(`âœ… Backend bundle created successfully at ${outfile}`);
    console.log(`ðŸ“¦ Bundle written to: ${outfile}`);

    return {
      outfile,
      mapfile,
      warnings: result.warnings,
      metafile: result.metafile
    };

  } catch (error) {
    throw new Error(`Failed to bundle backend program: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Convenience function to bundle and generate a backend program in one step
 */
export async function generateAndBundleBackend(options: {
  baseDir?: string;
  importPrefix?: string;
  outfile: string;
  minify?: boolean;
  sourcemap?: boolean;
  target?: string;
}): Promise<BackendBundleResult> {
  // Import the backend generator dynamically to avoid circular dependencies
  const { generateBackendProgram } = await import('./backend-generator.js');

  const generatedCode = await generateBackendProgram({
    baseDir: options.baseDir,
    importPrefix: options.importPrefix
  });

  // Write the generated code to a temporary file
  const tempInputFile = path.join(options.baseDir || process.cwd(), '.peaque', 'server_temp.ts');
  fs.mkdirSync(path.dirname(tempInputFile), { recursive: true });
  fs.writeFileSync(tempInputFile, generatedCode.content, 'utf-8');

  try {
    return await bundleBackendProgram({
      inputFile: tempInputFile,
      baseDir: options.baseDir,
      outfile: options.outfile,
      minify: options.minify,
      sourcemap: options.sourcemap,
      target: options.target
    });
  } finally {
    // Clean up temporary file
    try {
      fs.unlinkSync(tempInputFile);
    } catch (error) {
      // Ignore cleanup errors
    }
  }
}
