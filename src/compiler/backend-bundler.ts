import * as esbuild from 'esbuild';
import * as path from 'path';
import * as fs from 'fs';

export interface BackendBundleOptions {
  /** The generated TypeScript code from backend-generator.ts */
  generatedCode: string;
  /** Output file path for the bundled JavaScript */
  outputPath: string;
  /** Base directory of the project (for resolving relative imports) */
  baseDir?: string;
  /** Whether to minify the output */
  minify?: boolean;
  /** Whether to generate source maps */
  sourcemap?: boolean;
  /** Target Node.js version */
  target?: string;
}

/**
 * Bundles a generated backend server program into a single runnable JavaScript file using esbuild
 */
export async function bundleBackendProgram(options: BackendBundleOptions): Promise<void> {
  const {
    generatedCode,
    outputPath,
    baseDir = process.cwd(),
    minify = false,
    sourcemap = false,
    target = 'node18'
  } = options;

  try {
    // Parse the generated code to extract route import paths
    const routeImports: string[] = [];
    const importRegex = /import\s+{[^}]+}\s+from\s+["']([^"']+)["']/g;
    let match;
    while ((match = importRegex.exec(generatedCode)) !== null) {
      const importPath = match[1];
      // Add route imports to external list (exclude framework imports)
      if (importPath.startsWith('src/api/') && importPath.endsWith('/route.ts')) {
        routeImports.push(importPath);
      }
    }

  // Configure esbuild for Node.js bundling
  const esbuildOptions: esbuild.BuildOptions = {
    bundle: true,
    platform: 'node',
    target: target,
    format: 'esm', // Use ESM format for modern Node.js
    minify: minify,
    sourcemap: sourcemap,
    // Use stdin to pass generated code directly without temp file
    stdin: {
      contents: generatedCode,
      loader: 'ts',
      sourcefile: '_generated_backend.ts', // Virtual filename for source maps
      resolveDir: baseDir
    },
    outfile: outputPath,
    // Externalize Node.js built-ins, common packages, and route files
    external: [
      'fs',
      'path',
      'http',
      'https',
      'url',
      'querystring',
      'crypto',
      'util',
      'stream',
      'zlib',
      'events',
      'os',
      'child_process',
      'cluster',
      'worker_threads',
      'buffer',
      'assert',
      'constants',
      'timers',
      'dns',
      'net',
      'tls',
      'v8',
      'vm',
      // Externalize the framework itself since it will be a dependency
      //'@peaque/framework',
      // Externalize all route imports
      //...routeImports
    ],
    // Resolve imports relative to the base directory
    absWorkingDir: baseDir,
    // Handle TypeScript and JavaScript
    loader: {
      '.ts': 'ts',
      '.js': 'js',
      '.mjs': 'js',
      '.cjs': 'js'
    },
    // Resolve extensions
    resolveExtensions: ['.ts', '.js', '.mjs', '.cjs', '.json'],
    // Define environment variables
    define: {
      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'production')
    },
    // Banner for the output file
    banner: {
      js: `#!/usr/bin/env node\n// Generated by Peaque Framework Backend Bundler\n`
    },
    // Write the output as executable
    write: true,
    // Allow overwriting
    allowOverwrite: true,
    // Additional options for better compatibility
    mainFields: ['module', 'main'],
    conditions: ['node'],
    // Keep names for better debugging
    keepNames: !minify,
    // Tree shaking
    treeShaking: true
  };    // Run esbuild
    const result = await esbuild.build(esbuildOptions);

    // Check for build errors
    if (result.errors.length > 0) {
      const errorMessages = result.errors.map(error =>
        `${error.location?.file}:${error.location?.line}:${error.location?.column} - ${error.text}`
      );
      throw new Error(`Build failed:\n${errorMessages.join('\n')}`);
    }

    // Log warnings if any
    if (result.warnings.length > 0) {
      console.warn('Build warnings:');
      result.warnings.forEach(warning => {
        console.warn(`  ${warning.location?.file}:${warning.location?.line}:${warning.location?.column} - ${warning.text}`);
      });
    }

    // Make the output file executable
    try {
      fs.chmodSync(outputPath, '755');
    } catch (error) {
      // Ignore chmod errors on Windows
      if (process.platform !== 'win32') {
        console.warn(`Warning: Could not make output file executable: ${error}`);
      }
    }

    console.log(`âœ… Backend bundle created successfully: ${outputPath}`);
    console.log(`ðŸ“¦ Bundle size: ${fs.statSync(outputPath).size} bytes`);

  } catch (error) {
    throw new Error(`Failed to bundle backend program: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Convenience function to bundle and generate a backend program in one step
 */
export async function generateAndBundleBackend(options: {
  baseDir?: string;
  outputPath: string;
  importPrefix?: string;
  minify?: boolean;
  sourcemap?: boolean;
  target?: string;
}): Promise<void> {
  // Import the backend generator dynamically to avoid circular dependencies
  const { generateBackendProgram } = await import('./backend-generator.js');

  const generatedCode = await generateBackendProgram({
    baseDir: options.baseDir,
    importPrefix: options.importPrefix
  });

  await bundleBackendProgram({
    generatedCode,
    outputPath: options.outputPath,
    baseDir: options.baseDir,
    minify: options.minify,
    sourcemap: options.sourcemap,
    target: options.target
  });
}
