import * as esbuild from "esbuild"
import { OnResolveArgs, OnResolveResult, Plugin, PluginBuild } from "esbuild"
import { createRequire } from "module"
import path from "path"
import { fileURLToPath } from "url"
export interface BackendBundleOptions {
  /** The input TypeScript content as a string */
  inputContent: string
  /** Base directory of the project (for resolving relative imports) */
  baseDir?: string
  /** Output file path for the bundled JavaScript */
  outfile: string
  /** Whether to minify the output */
  minify?: boolean
  /** Whether to generate source maps */
  sourcemap?: boolean
  /** Target Node.js version */
  target?: string
}

export interface BackendBundleResult {
  /** The path to the output file */
  outfile: string
  /** The source map file path (if sourcemap was enabled) */
  mapfile?: string
  /** Any build warnings */
  warnings: esbuild.Message[]
  /** Build metadata */
  metafile?: esbuild.Metafile
}

const frameworkRequire = createRequire(import.meta.url)
const frameworkResolve = frameworkRequire.resolve

export function frameworkDepsPlugin(deps: string[]): Plugin {
  return {
    name: "framework-deps",
    setup: function (build: PluginBuild) {
      build.onResolve({ filter: /.*/ }, (args: OnResolveArgs): OnResolveResult | null => {
        if (deps.some(d => args.path === d || args.path.startsWith(d + "/"))) {
          try {
            const resolved = frameworkResolve(args.path)
            return { path: resolved }
          } catch(e) {
            console.warn("Failed to resolve framework dependency:", args.path, e instanceof Error ? e.message : e)
            return null
          }
        } else {
          return null
        }
      })
    },
  }
}

export function excludeDevModulesPlugin(): Plugin {
  return {
    name: "exclude-dev-modules",
    setup: function (build: PluginBuild) {
      // Prevent esbuild from loading dev-only modules by returning empty content
      build.onLoad({ filter: /.*/ }, (args) => {
        // Check if this is a dev-only module path
        if (args.path.includes("/server/dev-server") || args.path.includes("\\server\\dev-server") || args.path.includes("/jobs/jobs-runner") || args.path.includes("\\jobs\\jobs-runner") || args.path.includes("/hmr/module-loader") || args.path.includes("\\hmr\\module-loader") || args.path.includes("/compiler/hash-file") || args.path.includes("\\compiler\\hash-file") || args.path.includes("/cli/") || args.path.includes("\\cli\\")) {
          // Return empty module - prevents esbuild from processing these files and their imports
          return {
            contents: "// Dev-only module excluded from production bundle",
            loader: "js",
          }
        }
        return null
      })
    },
  }
}

/**
 * Bundles a generated backend server program into a single runnable JavaScript file using esbuild
 */
export async function bundleBackendProgram(options: BackendBundleOptions): Promise<BackendBundleResult> {
  const { inputContent, baseDir = process.cwd(), outfile, minify = false, sourcemap = false, target = "node18" } = options

  try {
    // Configure esbuild for Node.js bundling
    const esbuildOptions: esbuild.BuildOptions = {
      entryPoints: [],
      stdin: {
        contents: inputContent,
        loader: "ts",
        resolveDir: baseDir,
      },
      bundle: true,
      platform: "node",
      target: target,
      format: "cjs",
      outfile: outfile,
      minify: minify,
      sourcemap: sourcemap,
      // Externalize Node.js built-ins, common packages, and route files
      external: [
        "fs",
        "path",
        "http",
        "https",
        "url",
        "querystring",
        "crypto",
        "util",
        "stream",
        "zlib",
        "events",
        "os",
        "child_process",
        "cluster",
        "worker_threads",
        "buffer",
        "assert",
        "constants",
        "timers",
        "dns",
        "net",
        "tls",
        "v8",
        "vm",
        // "@prisma",
        // "esbuild"
      ],
      // Resolve imports relative to the base directory
      absWorkingDir: baseDir,
      // Handle TypeScript and JavaScript
      loader: {
        ".ts": "ts",
        ".js": "js",
        ".mjs": "js",
        ".cjs": "js",
      },
      // Resolve extensions
      resolveExtensions: [".ts", ".js", ".mjs", ".cjs", ".json"],
      // Define environment variables
      define: {
        "process.env.NODE_ENV": JSON.stringify(process.env.NODE_ENV || "production"),
      },
      // Banner for the output file
      banner: {
        js: `#!/usr/bin/env node\n// Generated by Peaque Framework Backend Bundler\n`,
      },
      // Additional options for better compatibility
      mainFields: ["module", "main"],
      conditions: ["node"],
      // Keep names for better debugging
      keepNames: !minify,
      // Tree shaking
      treeShaking: true,
      // Generate metafile for analysis
      metafile: true,
      plugins: [excludeDevModulesPlugin(), frameworkDepsPlugin(["croner", "react-refresh", "react", "react-dom", "tailwindcss", "dotenv"])],
    } // Run esbuild
    const result = await esbuild.build(esbuildOptions)

    // if (result.metafile) {
    //   const text = await esbuild.analyzeMetafile(result.metafile)
    //   fs.writeFileSync(outfile + ".meta.txt", text, "utf-8")
    // }

    // Check for build errors
    if (result.errors.length > 0) {
      const errorMessages = result.errors.map((error) => `${error.location?.file}:${error.location?.line}:${error.location?.column} - ${error.text}`)
      throw new Error(`Build failed:\n${errorMessages.join("\n")}`)
    }

    // Log warnings if any
    if (result.warnings.length > 0) {
      console.warn("Build warnings:")
      result.warnings.forEach((warning) => {
        console.warn(`  ${warning.location?.file}:${warning.location?.line}:${warning.location?.column} - ${warning.text}`)
      })
    }

    // Determine the output files
    const mapfile = sourcemap ? outfile + ".map" : undefined

    return {
      outfile,
      mapfile,
      warnings: result.warnings,
      metafile: result.metafile,
    }
  } catch (error) {
    throw new Error(`Failed to bundle backend program: ${error instanceof Error ? error.message : String(error)}`)
  }
}
