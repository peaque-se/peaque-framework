import * as fs from "fs"
import path from "path"
import colors from "yoctocolors"
import { precompressAssets } from "../assets/precompress-assets.js"
import { mergeHead, renderHead } from "../client/head.js"
import { bundleBackendProgram } from "./backend-bundler.js"
import { FrontendBundler } from "./frontend-bundler.js"
import { bundleCssFile } from "./tailwind-bundler.js"
import { ModuleLoader } from "../hmr/module-loader.js"
import { HeadDefinition } from "../index.js"
import { buildRouter, RouteFileConfig } from "../router/builder.js"
import { RouteNode } from "../router/router.js"
import { serializeRouterToJs } from "../router/serializer.js"
import { platformVersion } from "../server/version.js"

const pageRouterConfig: RouteFileConfig[] = [
  { pattern: "page.tsx", property: "page", stacks: false, accept: true },
  { pattern: "layout.tsx", property: "layout", stacks: true },
  { pattern: "guard.ts", property: "guards", stacks: true },
  { pattern: "head.ts", property: "heads", stacks: true },
  { pattern: "middleware.ts", property: "middleware", stacks: false },
]

const apiRouterConfig: RouteFileConfig[] = [
  { pattern: "route.ts", property: "handler", stacks: false, accept: true },
  { pattern: "middleware.ts", property: "middleware", stacks: true },
]

function componentify(router: RouteNode<string>, baseDir: string): Set<string> {
  const imports = new Set<string>()

  function getComponentName(filePath: string): string {
    const relativePath = path.relative(baseDir, filePath)
    const componentName = relativePath
      .replace(/[^a-zA-Z0-9]/g, " ")
      .split(" ")
      .map((word: string) => word.charAt(0).toUpperCase() + word.slice(1))
      .join("")
    return componentName
  }

  function traverse(node: RouteNode<string>) {
    if (node.names) {
      for (const key in node.names) {
        const name = node.names[key]
        const componentName = getComponentName(name)
        node.names[key] = componentName
        const filename = path.relative(baseDir, name)
        imports.add(`import ${componentName} from "../src/pages/${filename.replace(/\\/g, "/")}";`)
      }
    }
    if (node.stacks) {
      for (const key in node.stacks) {
        node.stacks[key] = node.stacks[key].map((name: string) => {
          const componentName = getComponentName(name)
          const filename = path.relative(baseDir, name)
          imports.add(`import ${componentName} from "../src/pages/${filename.replace(/\\/g, "/")}";`)
          return componentName
        })
      }
    }
    for (const child of node.staticChildren.values()) {
      traverse(child)
    }
    if (node.paramChild) {
      traverse(node.paramChild)
    }
    if (node.wildcardChild) {
      traverse(node.wildcardChild)
    }
  }

  traverse(router)
  return imports
}

function checkSpecialPage(pagesDir: string, fileName: string): string | null {
  const filePath = path.join(pagesDir, fileName)
  if (fs.existsSync(filePath)) {
    const relativePath = path.relative(pagesDir, filePath).replace(/\\/g, "/")
    let componentName: string
    if (fileName === "loading.tsx") componentName = "Loading"
    else if (fileName === "404.tsx") componentName = "Missing"
    else if (fileName === "error.tsx") componentName = "Error"
    else if (fileName === "403.tsx") componentName = "AccessDenied"
    else componentName = relativePath.replace(/[^a-zA-Z0-9]/g, "_").replace(/^_+|_+$/g, "")
    return componentName
  }
  return null
}

function generateFrontendRouterJs(router: RouteNode<string>, imports: Set<string>, basePath: string): string {
  const result: string[] = []
  result.push(`// Auto-generated by Peaque Production Builder`)
  result.push(`// Do not edit this file directly\n`)
  result.push(`import { StrictMode } from "react"`)
  result.push(`import { createRoot } from "react-dom/client"`)
  result.push(`import { Router } from "@peaque/framework"`)
  result.push(...Array.from(imports))

  // Check for special pages
  const pagesDir = path.join(basePath, "src/pages")
  const loadingPage = checkSpecialPage(pagesDir, "loading.tsx")
  const missingPage = checkSpecialPage(pagesDir, "404.tsx")
  const errorPage = checkSpecialPage(pagesDir, "error.tsx")
  const accessDeniedPage = checkSpecialPage(pagesDir, "403.tsx")

  // Add imports for special pages
  if (loadingPage) {
    result.push(`import ${loadingPage} from "../src/pages/loading.tsx";`)
  }
  if (missingPage) {
    result.push(`import ${missingPage} from "../src/pages/404.tsx";`)
  }
  if (errorPage) {
    result.push(`import ${errorPage} from "../src/pages/error.tsx";`)
  }
  if (accessDeniedPage) {
    result.push(`import ${accessDeniedPage} from "../src/pages/403.tsx";`)
  }

  result.push(serializeRouterToJs(router, true))
  result.push(`const conf = {`)
  result.push(`  root: router,`)

  // Add special page props to configuration
  if (loadingPage) {
    result.push(`  loading: <${loadingPage} />,`)
  }
  if (missingPage) {
    result.push(`  missing: <${missingPage} />,`)
  }
  if (errorPage) {
    result.push(`  error: <${errorPage} />,`)
  }
  if (accessDeniedPage) {
    result.push(`  accessDenied: <${accessDeniedPage} />,`)
  }

  result.push(`}`)
  result.push(`createRoot(document.getElementById('peaque')!).render(<StrictMode><Router {...conf} /></StrictMode>)`)
  return result.join("\n")
}

async function extractHeadStacks(router: RouteNode<string>, basePath: string, pagesDir: string): Promise<Map<string, { headStack: string[], html: string }>> {
  const defaultHead: HeadDefinition = {
    title: "Peaque Framework Application",
    meta: [
      { name: "viewport", content: "width=device-width, initial-scale=1" },
      { name: "description", content: "A Peaque Framework Application" },
    ],
    link: [{ rel: "stylesheet", href: "/peaque.css" }],
  }

  const headLoader = new ModuleLoader()
  const headStacks = new Map<string, { headStack: string[], html: string }>()
  const routesToProcess: Array<{ path: string; headStack: string[] }> = []

  // Traverse router to find all routes with head stacks
  function traverse(node: RouteNode<string>, currentPath: string, accumulatedHeads: string[]) {
    const heads = node.stacks?.heads ? [...accumulatedHeads, ...node.stacks.heads] : accumulatedHeads

    if (node.accept) {
      routesToProcess.push({ path: currentPath || "/", headStack: heads })
    }

    for (const [key, child] of node.staticChildren.entries()) {
      traverse(child, currentPath + "/" + key, heads)
    }
    if (node.paramChild) {
      traverse(node.paramChild, currentPath + "/:" + node.paramChild.paramName, heads)
    }
    if (node.wildcardChild) {
      traverse(node.wildcardChild, currentPath + "/*" + node.wildcardChild.paramName, heads)
    }
  }

  traverse(router, "", [])

  // Process each unique head stack
  for (const route of routesToProcess) {
    const stackKey = route.headStack.length > 0
      ? route.headStack.map(f => f.replace(/[^a-zA-Z0-9]/g, "_")).join("_")
      : "default"

    if (!headStacks.has(stackKey)) {
      let head = defaultHead

      for (const headFile of route.headStack) {
        let filename = path.isAbsolute(headFile) ? headFile : path.join(pagesDir, headFile)
        filename = path.dirname(filename) + "/head.ts"
        try {
          const mod = await headLoader.loadModule(filename)
          head = mergeHead(head, mod.default)
        } catch (err) {
          console.warn(`Warning: Could not load head file ${filename}:`, err)
        }
      }

      const renderedHead = renderHead(head)
      const indexHtml = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
${renderedHead}
</head>
<body>
<div id="peaque"></div>
<script type="module" src="/peaque.js"></script>
</body>
</html>`

      headStacks.set(stackKey, { headStack: route.headStack, html: indexHtml })
    }
  }

  // Ensure there's at least a default head
  if (headStacks.size === 0) {
    const renderedHead = renderHead(defaultHead)
    const indexHtml = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
${renderedHead}
</head>
<body>
<div id="peaque"></div>
<script type="module" src="/peaque.js"></script>
</body>
</html>`
    headStacks.set("default", { headStack: [], html: indexHtml })
  }

  return headStacks
}

function detectExportedMethods(filePath: string): string[] {
  const fileContent = fs.readFileSync(filePath, "utf-8")
  const methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"]
  const exportedMethods: string[] = []

  for (const method of methods) {
    // Match various export patterns:
    // export function GET(
    // export const GET =
    // export async function GET(
    const exportRegex = new RegExp(`export\\s+(?:async\\s+)?(?:function|const|let|var)\\s+${method}\\b`, 'm')
    if (exportRegex.test(fileContent)) {
      exportedMethods.push(method)
    }
  }

  return exportedMethods
}

function generateBackendServerCode(apiRouter: RouteNode<string>, headStacks: Map<string, { headStack: string[], html: string }>, pageRouter: RouteNode<string>, basePath: string): string {
  const imports: string[] = []
  const htmlConstants: string[] = []
  const routerCalls: string[] = []

  imports.push(`import { Router, HttpServer, addAssetRoutesForFolder, executeMiddlewareChain } from "@peaque/framework/server"`)
  imports.push(`import { JobsRunner } from "@peaque/framework/server"`)

  // Generate HTML content constants
  for (const [stackKey, { html }] of headStacks) {
    htmlConstants.push(`const index_${stackKey} = \`${html}\``)
  }

  // Generate imports for API route handlers with method detection
  const handlerImports: Array<{ alias: string; path: string; file: string; methods: string[] }> = []
  function traverseApiRoutes(node: RouteNode<string>, currentPath: string = "") {
    if (node.names?.handler) {
      const handlerFile = node.names.handler
      const relativePath = path.relative(basePath, handlerFile).replace(/\\/g, "/")
      const alias = relativePath.replace(/[^a-zA-Z0-9]/g, "_")
      const methods = detectExportedMethods(handlerFile)
      handlerImports.push({ alias, path: "../" + relativePath, file: handlerFile, methods })
    }

    for (const [key, child] of node.staticChildren.entries()) {
      traverseApiRoutes(child, currentPath + "/" + key)
    }
    if (node.paramChild) {
      traverseApiRoutes(node.paramChild, currentPath + "/:" + node.paramChild.paramName)
    }
    if (node.wildcardChild) {
      traverseApiRoutes(node.wildcardChild, currentPath + "/*")
    }
  }

  traverseApiRoutes(apiRouter)

  // Add handler imports with only the methods that exist
  for (const { alias, path: importPath, methods } of handlerImports) {
    if (methods.length > 0) {
      const methodImports = methods.map(m => `${m} as ${alias}_${m}`).join(", ")
      imports.push(`import { ${methodImports} } from "${importPath}"`)
    }
  }

  // Check for startup and middleware
  let startupImport = ""
  let rootMiddleware = ""
  if (fs.existsSync(path.join(basePath, "src", "startup.ts"))) {
    startupImport = `import * as ThrowawayStartup from "../src/startup.ts"`
  }
  if (fs.existsSync(path.join(basePath, "src", "middleware.ts"))) {
    rootMiddleware = `import { middleware as AbsoluteRootMiddleware } from "../src/middleware.ts"`
  }

  if (startupImport) imports.push(startupImport)
  if (rootMiddleware) imports.push(rootMiddleware)

  // Create a map of handler file to methods for easy lookup
  const handlerMethodsMap = new Map<string, string[]>()
  for (const { file, methods } of handlerImports) {
    handlerMethodsMap.set(file, methods)
  }

  // Generate the router setup function
  const routerFunction = [
    "export async function makeBackendRouter() {",
    "  const router = new Router()",
  ]

  // Add API route registrations
  function generateApiRouteRegistrations(node: RouteNode<string>, currentPath: string = "") {
    if (node.names?.handler) {
      const handlerFile = node.names.handler
      const relativePath = path.relative(basePath, handlerFile).replace(/\\/g, "/")
      const alias = relativePath.replace(/[^a-zA-Z0-9]/g, "_")
      const routePath = "/api" + currentPath

      const methods = handlerMethodsMap.get(handlerFile) || []
      for (const method of methods) {
        routerFunction.push(`  router.addRoute("${method}", "${routePath}", ${alias}_${method})`)
      }
    }

    for (const [key, child] of node.staticChildren.entries()) {
      const nextPath = child.excludeFromPath ? currentPath : currentPath + "/" + key
      generateApiRouteRegistrations(child, nextPath)
    }
    if (node.paramChild) {
      generateApiRouteRegistrations(node.paramChild, currentPath + "/:" + node.paramChild.paramName)
    }
    if (node.wildcardChild) {
      generateApiRouteRegistrations(node.wildcardChild, currentPath + "/*" + node.wildcardChild.paramName)
    }
  }

  generateApiRouteRegistrations(apiRouter)

  // Add page route registrations with head stacks
  function generatePageRouteRegistrations(node: RouteNode<string>, currentPath: string = "", accumulatedHeads: string[] = []) {
    const heads = node.stacks?.heads ? [...accumulatedHeads, ...node.stacks.heads] : accumulatedHeads

    if (node.accept) {
      const routePath = currentPath || "/"
      const stackKey = heads.length > 0
        ? heads.map(f => f.replace(/[^a-zA-Z0-9]/g, "_")).join("_")
        : "default"
      routerFunction.push(`  router.addRoute("GET", "${routePath}", (req) => { req.type("text/html").send(index_${stackKey}) })`)
    }

    for (const [key, child] of node.staticChildren.entries()) {
      const nextPath = child.excludeFromPath ? currentPath : currentPath + "/" + key
      generatePageRouteRegistrations(child, nextPath, heads)
    }
    if (node.paramChild) {
      generatePageRouteRegistrations(node.paramChild, currentPath + "/:" + node.paramChild.paramName, heads)
    }
    if (node.wildcardChild) {
      generatePageRouteRegistrations(node.wildcardChild, currentPath + "/*" + node.wildcardChild.paramName, heads)
    }
  }

  generatePageRouteRegistrations(pageRouter)

  // Add asset routes
  routerFunction.push(`  await addAssetRoutesForFolder(router, \`\${process.cwd()}/assets\`, "/")`)
  routerFunction.push("  return router")
  routerFunction.push("}")

  // Generate main startup function
  const startupFunction = [
    "async function main() {",
    "  const args = process.argv.slice(1)",
    '  const portIndex = args.findIndex(arg => arg === "-p" || arg === "--port")',
    "  const port = portIndex !== -1 && args.length > portIndex + 1 ? parseInt(args[portIndex + 1], 10) : 3000",
    "  const router = await makeBackendRouter()",
    rootMiddleware
      ? "  const handler = async (req) => { await executeMiddlewareChain(req, [AbsoluteRootMiddleware], router.getRequestHandler()) }"
      : "  const handler = router.getRequestHandler()",
    "  const server = new HttpServer(handler)",
    "  const jobsRunner = new JobsRunner(process.cwd())",
    "  await jobsRunner.startOrUpdateJobs()",
    "  server.startServer(port)",
    `  console.log("ðŸŒ  ${colors.bold(colors.yellow("Peaque Framework " + platformVersion))} production server")`,
    `  console.log("     ${colors.green("âœ“")} Listening on port " + port)`,
    `  console.log("     ${colors.green("âœ“")} Process id " + process.pid)`,
    `  console.log("     ${colors.green("âœ“")} Happy browsing!")`,
    "  process.on('SIGINT', () => {",
    "    jobsRunner.stop()",
    "    server.stop()",
    "    process.exit(0)",
    "  })",
    "  process.on('SIGTERM', () => {",
    "    jobsRunner.stop()",
    "    server.stop()",
    "    process.exit(0)",
    "  })",
    "}",
    "main()",
  ]

  return [...imports, "", ...htmlConstants, "", ...routerFunction, "", ...startupFunction].join("\n")
}

export const buildForProduction = async (basePath: string) => {
  const startTime = Date.now()
  console.log(`ðŸ“¦  ${colors.bold(colors.yellow("Peaque Framework " + platformVersion))} building for production`)
  console.log(`     ${colors.green("âœ“")} Base path ${colors.gray(`${basePath}`)}`)
  const outDir = path.join(basePath, "dist")
  const assetDir = path.join(outDir, "assets")
  fs.mkdirSync(assetDir, { recursive: true })

  // Build frontend router
  const frontend = buildRouter(basePath + "/src/pages", pageRouterConfig) as RouteNode<string>
  const frontendImports = componentify(frontend, basePath + "/src/pages")
  const frontendJs = generateFrontendRouterJs(frontend, frontendImports, basePath)

  // Bundle frontend
  const jsBundler = new FrontendBundler({
    entryContent: frontendJs,
    baseDir: outDir,
    sourcemap: false,
    writeToFile: true,
    outputFile: path.join(assetDir, "peaque.js"),
  })
  const result = await jsBundler.build()
  if (result.errors && result.errors.length > 0) {
    console.error("Errors during JS bundling:", result.errors)
    process.exit(1)
  }
  // Filter out esbuild require.resolve warning since we want esbuild bundled
  if (result.warnings && result.warnings.length > 0) {
    const filteredWarnings = result.warnings.filter(warning =>
      !warning.includes('"esbuild" should be marked as external for use with "require.resolve"')
    )
    if (filteredWarnings.length > 0) {
      console.warn("Warnings during JS bundling:", filteredWarnings)
    }
  }

  // Bundle CSS
  const stylePath = path.join(basePath, "src/styles.css")
  const cssContent = fs.readFileSync(stylePath, "utf-8")
  const newCssContent = await bundleCssFile(cssContent, basePath)
  fs.writeFileSync(path.join(assetDir, "peaque.css"), newCssContent, "utf-8")

  // Copy public folder
  await fs.promises.cp(path.join(basePath, "src/public"), assetDir, { recursive: true })

  // Precompress assets
  await precompressAssets(assetDir)

  // Extract head stacks from frontend router
  const headStacks = await extractHeadStacks(frontend, basePath, basePath + "/src/pages")

  // Build backend router
  const backend = buildRouter(basePath + "/src/api", apiRouterConfig) as RouteNode<string>

  // Generate backend server code
  const backendCode = generateBackendServerCode(backend, headStacks, frontend, basePath)

  // Write backend code
  fs.writeFileSync(path.join(outDir, "server_without_env.js"), backendCode, "utf-8")

  // Create main.js with env loading
  const mainJs = `import dotenv from "dotenv"
const currentPath = process.cwd()
dotenv.config({path: \`\${currentPath}/.env\`, override: true})
dotenv.config()
require("./server_without_env.js")
`
  await bundleBackendProgram({
    baseDir: outDir,
    outfile: path.join(outDir, "main.cjs"),
    inputContent: mainJs,
    minify: true,
    sourcemap: false,
  })

  //fs.unlinkSync(path.join(outDir, "server_without_env.js"))

  const endTime = Date.now()
  console.log(`     ${colors.green("âœ“")} Production build completed ${colors.bold(colors.green("successfully"))} in ${((endTime - startTime) / 1000).toFixed(2)} seconds`)

  // print some statistics about the build (file sizes etc)
  const filesToStat = ["peaque.js", "peaque.css"]
  for (const file of filesToStat) {
    const filePath = path.join(assetDir, file)
    const fileStats = fs.statSync(filePath)
    console.log(`     ${colors.green("âœ“")} Final ${colors.gray(file)} size: ${colors.gray((fileStats.size / 1024).toFixed(2))} KB`)
  }

}
